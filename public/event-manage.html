<!doctype html>
<html>
  <head>
    <title>Tournament Scheduler</title>
    <style>
      body {
        padding: 20px;
      }

      .matches {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 16px;
      }

      .match {
        border-radius: 8px;
        padding: 10px;
        background: #364153;
        width: 250px;
      }

      .players {
        margin-top: 6px;
      }

      .player {
        min-width: 100px;
        background: #384b6b;
        padding: 6px;
        border-radius: 6px;
        cursor: grab;
        text-align: center;
      }

      #scheduleColumn .player {
        /* border: 1px solid #ddd; */
        padding: 8px;
        margin: 4px;
      }

      .player.invalid {
        background: #521212;
        border-color: #ff4d4f;
      }

      .player.valid {
        outline: 2px dashed #4caf50;
      }

      .player.drag-over {
        outline: 2px dashed #4caf50;
      }

      #playerPalette .player {
        min-width: 150px;
        margin-bottom: 8px;
      }

      #playerPalette .palette-player {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }

      .game-count {
        min-width: 26px;
        text-align: center;
        font-size: 12px;
        font-weight: bold;
        padding: 2px 6px;
        border-radius: 12px;
        background: #2d3b55;
      }

      .game-count.above-average {
        background: #45803a;
      }

      .game-count.below-average {
        background: #805d1c;
      }

      #playerPalette {
        position: sticky;
        top: 100px;
        width: 220px;
        padding: 10px;
        background: #1f2633;
        border-radius: 8px;
        max-height: calc(100vh - 100px);
        height: fit-content;
      }

      .selected-player {
        outline: 3px solid #4fa1ff;
        outline-offset: 2px;
        box-shadow: 0 0 6px rgba(79, 120, 255, 0.6);
      }

      .selected-player-below-average {
        outline: 3px solid #b19c23;
        outline-offset: 2px;
        box-shadow: 0 0 6px rgba(255, 213, 79, 0.6);
      }

      .selected-player-above-average {
        outline: 3px solid #50a141;
        outline-offset: 2px;
        box-shadow: 0 0 6px rgba(79, 255, 117, 0.6);
      }

      .match .player.dimmed {
        opacity: 0.3;
      }

      #playerPalette h3,
      .alerts-panel h3 {
        margin-top: 0;
      }

      .match .player.highlighted {
        font-weight: bold;
        background-color: #506080;
      }

      #playerList {
        overflow-y: auto;
        padding: 0px 8px;
        flex: 1;
      }

      .alerts-panel {
        position: sticky;
        top: 100px;
        width: 220px;
        padding: 10px;
        background: #1f2633;
        border-radius: 8px;
        max-height: calc(100vh - 100px);
        height: fit-content;
      }

      .alert-row {
        cursor: pointer;
        padding: 8px;
        margin: 10px 4px;
        border-radius: 4px;
        background: #805d1c;
        min-width: 150px;
      }

      .alert-row:hover {
        background: #a87920;
      }

      .team {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        grid-template-columns: repeat(2, 1fr);
        width: 100%;
      }

      .vs {
        grid-column: 1 / -1;
        text-align: center;
        font-weight: bold;
        margin: 4px 0;
      }

      /* Wrapper when two-column mode is on */
      .schedule-columns {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
      }

      /* .schedule-column + .schedule-column {
			border-left: 1px solid #FFFFFF;
			margin-left: 10px;
			padding-left: 10px;
		} */

      .schedule-column {
        display: flex;
        flex-direction: column;
        gap: 16px;
        max-width: 600px;
      }

      h3 {
        margin-top: 0px;
      }

      @media print {
        .team {
          border: 1px solid #000000;
        }

        header,
        #playerPalette,
        #alerts {
          display: none !important;
        }

        .match {
          padding: 0;
        }

        html,
        body {
          color: #000 !important;
        }

        body,
        h2 {
          padding: 0;
          margin: 0;
        }

        h3 {
          padding: 0;
          margin-top: 0px;
          margin-bottom: 4px;
        }

        #scheduleColumn .player {
          padding: 1;
        }
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
    <link rel="stylesheet" href="./css/style.css" />
    <link rel="icon" href="./icon/favicon.ico" type="image/x-icon" />
    <link rel="icon" type="image/png" href="./icon/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="./icon/favicon.svg" />
  </head>
  <body>
    <!-- <button onclick="navigateToHome()">[Home]</button> -->
    <body>
      <!-- Header -->
      <header
        style="
          display: flex;
          align-items: center;
          justify-content: flex-start;
          gap: 12px;
          padding: 12px 20px;
          background: #1f2633;
          color: #fff;
          border-radius: 8px;
          margin-bottom: 20px;
        "
      >
        <!-- Left side buttons -->
        <button onclick="navigateCreate()">[Create]</button>
        <button onclick="navigateToHome()">[Home]</button>
        <button onclick="generateReadOnlyUrl()">[Share Read-Only Link]</button>

        <!-- Right side controls -->
        <div style="margin-left: auto; display: flex; align-items: center; gap: 12px">
          <button onclick="undoSwap()">[Undo swap]</button>
          <button id="globalSwapBtn" onclick="toggleGlobalSwap()">[Global player swap: No]</button>
          <button id="toggleRoundColumnsBtn">[Two Columns: Off]</button>
          <button id="randomSeedBtn">[Randomize Seed]</button>
        </div>
      </header>

      <div style="display: flex; gap: 20px">
        <!-- Player Palette -->
        <div id="playerPalette">
          <h3>Players (<span id="playerCount"></span>)</h3>
          <div id="playerList"></div>
        </div>

        <!-- Schedule Column -->
        <div id="scheduleColumn" style="flex: 1; max-width: 1200px">
          <h2 id="scheduleTitle">Schedule</h2>
          <div id="schedule"></div>
        </div>

        <!-- Alerts -->
        <div id="alerts" class="alerts-panel"></div>
      </div>
    </body>

    <script>
      function mulberry32(seed) {
        return function () {
          let t = (seed += 0x6d2b79f5);
          t = Math.imul(t ^ (t >>> 15), t | 1);
          t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      }

      const queryString = window.location.search;
      const hash = window.location.hash.substring(1);
      let globalSwap = false;

      let twoColumnRounds = false;

      const params = new URLSearchParams(queryString ? queryString : hash);
      const isReadOnly = params.get("data");

      let playerNames = [];
      let SEED = Date.now();

      const PLAYERS_PER_MATCH = 4;
      const MAX_UNDO = 100;

      let TITLE = "Tournament";
      let GAME_LENGTH_MIN = 20;
      let COURTS = 2;
      let TOTAL_PLAYERS = 16;
      let TOTAL_MATCHES = 12;
      let START_TIME = "18:00";
      let SLOTS = TOTAL_MATCHES / COURTS;

      if (isReadOnly) {
        console.log("Reading from data param");
      } else {
        const title = params.get("title");
        const startTime = params.get("startTime");
        const endTime = params.get("endTime");
        const matchLength = params.get("matchLength");
        const courtCount = params.get("courtCount");
        const seed = params.get("seed");
        const playersStr = params.get("players");

        playerNames = playersStr ? playersStr.split(",").filter(Boolean) : [];
        SEED = seed ? Number(seed) : Date.now();

        const startMinutes = timeStringToMinutes(startTime);
        const endMinutes = timeStringToMinutes(endTime);
        const TOTAL_MATCHES = courtCount * ((endMinutes - startMinutes) / Number(matchLength));

        TITLE = title;
        GAME_LENGTH_MIN = Number(matchLength);
        COURTS = courtCount;
        TOTAL_PLAYERS = playerNames.length;
        START_TIME = startTime;
        SLOTS = TOTAL_MATCHES / COURTS;
      }

      console.log("Players:", playerNames);
      console.log("GAME_LENGTH_MIN:", GAME_LENGTH_MIN);
      console.log("COURTS:", COURTS);
      console.log("TOTAL_PLAYERS:", TOTAL_PLAYERS);
      console.log("START_TIME:", START_TIME);
      console.log("SLOTS:", SLOTS);
      console.log("SEED:", SEED);
      console.log("TOTAL_MATCHES:", TOTAL_MATCHES);

      const rand = mulberry32(SEED);

      let playerSortMode = "alpha"; // "alpha" | "games-desc" | "games-asc"

      let undoStack = [];
      let players = [];
      let courtNames = Array.from({ length: COURTS }, (_, i) => `Court ${i + 1}`);

      let schedule = [];
      let selectedPlayerIds = new Set();

      schedule = parseScheduleFromUrl(params.get("data")) || generateSchedule();
      render();
      renderPlayerPalette();
      renderAlerts();
      console.log(schedule);

      document.title = TITLE;
      document.getElementById("scheduleTitle").textContent = TITLE;

      const palette = document.getElementById("playerPalette");
      const alertsPanel = document.getElementById("alerts");

      const togglePaletteBtn = document.getElementById("togglePaletteBtn");
      const toggleAlertsBtn = document.getElementById("toggleAlertsBtn");

      document.getElementById("randomSeedBtn").addEventListener("click", () => {
        SEED = Math.floor(Math.random() * 1000000000);
        console.log("New SEED:", SEED);

        params.set("seed", SEED);

        let newUrl;
        if (queryString) {
          newUrl = `${window.location.pathname}?${params.toString()}`;
        } else {
          newUrl = `${window.location.pathname}#${params.toString()}`;
        }

        window.location.href = newUrl;
        window.location.reload();
      });

      document.getElementById("toggleRoundColumnsBtn").addEventListener("click", () => {
        twoColumnRounds = !twoColumnRounds;
        document.getElementById("toggleRoundColumnsBtn").textContent = `[Two Columns: ${twoColumnRounds ? "On" : "Off"}]`;
        render();
      });

      togglePaletteBtn?.addEventListener("click", () => {
        if (palette.style.display === "none") {
          palette.style.display = "block";
          togglePaletteBtn.textContent = "[Hide Players]";
        } else {
          palette.style.display = "none";
          togglePaletteBtn.textContent = "[Show Players]";
        }
      });

      toggleAlertsBtn?.addEventListener("click", () => {
        if (alertsPanel.style.display === "none") {
          alertsPanel.style.display = "block";
          toggleAlertsBtn.textContent = "[Hide Alerts]";
        } else {
          alertsPanel.style.display = "none";
          toggleAlertsBtn.textContent = "[Show Alerts]";
        }
      });

      function generateReadOnlyUrl() {
        const courtsStr = courtNames.join(",");
        const timesStr = schedule.map((s) => s.startTime).join(",");
        const playersStr = schedule.flatMap((s) => s.matches.flatMap((m) => m.players.map((p) => p.name))).join(",");

        const flatStr = `${TITLE}|${courtsStr}|${timesStr}|${playersStr}`;

        // Compress to URL-safe string
        const compressed = LZString.compressToEncodedURIComponent(flatStr);

        // Put in query param
        const url = `${window.location.origin}${window.location.pathname}?data=${compressed}`;

        window.open(url, "_blank");
      }

      function parseScheduleFromUrl(compressed) {
        if (!compressed) return null;

        const flatStr = LZString.decompressFromEncodedURIComponent(compressed);
        if (!flatStr) return null;

        console.log(flatStr);
        const [title, courtsStr, timesStr, playersStr] = flatStr.split("|");
        console.log(title, courtsStr, timesStr, playersStr);

        const courts = courtsStr.split(",");
        const times = timesStr.split(",");
        const playersFlat = playersStr.split(",");

        // Rebuild schedule
        const slots = times.map((time, idx) => {
          const matches = [];
          for (let c = 0; c < courts.length; c++) {
            const start = (idx * courts.length + c) * 4;
            const matchPlayers = playersFlat.slice(start, start + 4).map((name, i) => ({
              id: `p${start + i + 1}`,
              name,
            }));
            matches.push({ id: `m${idx * courts.length + c + 1}`, court: c + 1, players: matchPlayers });
          }
          return { id: `s${idx + 1}`, startTime: time, matches };
        });

        courtNames = courts;
        TITLE = title;

        return slots;
      }

      function timeStringToMinutes(timeStr) {
        const [hours, minutes] = timeStr.split(":").map(Number);
        return hours * 60 + minutes;
      }

      function generateScheduleRelaxed() {
        function shuffle(array) {
          const arr = [...array];
          for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(rand() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
          }
          return arr;
        }

        players = shuffle(playerNames)
          .slice(0, TOTAL_PLAYERS)
          .map((name, i) => ({ id: "p" + (i + 1), name }));

        function generateSingleSchedule() {
          let matchId = 1;
          let minutes = timeStringToMinutes(START_TIME);
          const slots = [];
          const playerCounts = {};
          players.forEach((p) => (playerCounts[p.id] = 0));

          for (let s = 0; s < SLOTS; s++) {
            const matches = [];
            const slotUsedPlayers = new Set();

            for (let c = 1; c <= COURTS; c++) {
              const availablePlayers = players.filter((p) => !slotUsedPlayers.has(p.id));
              const minMatches = Math.min(...availablePlayers.map((p) => playerCounts[p.id]));
              let candidates = availablePlayers.filter((p) => playerCounts[p.id] === minMatches);
              candidates = candidates.sort(() => rand() - 0.5);

              const matchPlayers = [];
              while (matchPlayers.length < PLAYERS_PER_MATCH) {
                if (candidates.length === 0) {
                  const remaining = availablePlayers.filter((p) => !matchPlayers.includes(p));
                  candidates = remaining.sort(() => rand() - 0.5);
                }
                matchPlayers.push(candidates.pop());
              }

              matchPlayers.forEach((p) => slotUsedPlayers.add(p.id));
              matchPlayers.forEach((p) => playerCounts[p.id]++);
              matches.push({ id: "m" + matchId++, court: c, players: matchPlayers });
            }

            slots.push({ id: "s" + (s + 1), startTime: minutesToTime(minutes), matches });
            minutes += GAME_LENGTH_MIN;
          }

          return slots;
        }

        let bestSchedule = null;
        let minTotalCollisions = Infinity;

        for (let i = 0; i < 5000; i++) {
          const schedule = generateSingleSchedule();
          const { togetherMap, againstMap } = generatePairAlerts(schedule);

          var tempAlert = buildAlertList(schedule);
          const totalCollisions = tempAlert.reduce((sum, e) => sum + e.count, 0);

          if (totalCollisions < minTotalCollisions) {
            minTotalCollisions = totalCollisions;
            bestSchedule = schedule;
          }

          // Early exit if perfect schedule found
          if (totalCollisions === TOTAL_PLAYERS * (SLOTS * COURTS * (PLAYERS_PER_MATCH - 1))) break;
        }

        return bestSchedule;
      }

      function generateSchedule(maxRetries = 100) {
        let attempt = 0;
        let schedule = null;

        while (attempt < maxRetries) {
          attempt++;
          try {
            // --- Initialize ---
            players = playerNames.slice(0, TOTAL_PLAYERS).map((name, i) => ({
              id: "p" + (i + 1),
              name: name,
            }));

            let matchId = 1;
            let minutes = timeStringToMinutes(START_TIME);
            const slots = [];

            const gamesPerPlayer = (TOTAL_MATCHES * PLAYERS_PER_MATCH) / TOTAL_PLAYERS;

            const playedWith = {};
            const matchCounts = {};
            players.forEach((p) => {
              playedWith[p.id] = new Set();
              matchCounts[p.id] = 0;
            });

            // --- Build schedule ---
            for (let s = 0; s < SLOTS; s++) {
              const matches = [];
              const slotUsedPlayers = new Set();

              for (let c = 1; c <= COURTS; c++) {
                let availablePlayers = players.filter((p) => !slotUsedPlayers.has(p.id) && matchCounts[p.id] < gamesPerPlayer);

                const matchPlayers = [];

                while (matchPlayers.length < PLAYERS_PER_MATCH) {
                  const candidates = availablePlayers.filter((p) => !matchPlayers.some((mp) => playedWith[p.id].has(mp.id)));

                  if (candidates.length === 0) {
                    // Fail this attempt
                    throw new Error("No valid candidates, retrying...");
                  }

                  const idx = Math.floor(rand() * candidates.length);
                  const selected = candidates[idx];
                  matchPlayers.push(selected);
                  availablePlayers = availablePlayers.filter((p) => p.id !== selected.id);
                }

                // Update slotUsedPlayers, pairing history, and counts
                matchPlayers.forEach((p) => slotUsedPlayers.add(p.id));
                for (let i = 0; i < matchPlayers.length; i++) {
                  matchCounts[matchPlayers[i].id]++;
                  for (let j = 0; j < matchPlayers.length; j++) {
                    if (i !== j) playedWith[matchPlayers[i].id].add(matchPlayers[j].id);
                  }
                }

                matches.push({
                  id: "m" + matchId++,
                  court: c,
                  players: matchPlayers,
                });
              }

              slots.push({
                id: "s" + (s + 1),
                startTime: minutesToTime(minutes),
                matches,
              });

              minutes += GAME_LENGTH_MIN;
            }

            // --- Check if perfectly balanced ---
            const allBalanced = players.every((p) => matchCounts[p.id] === gamesPerPlayer);
            if (!allBalanced) throw new Error("Unbalanced, retrying...");

            console.log("Perfect schedule generated on attempt", attempt);
            console.log("Matches per player:", matchCounts);
            schedule = slots;
            break; // success
          } catch (err) {
            if (attempt === maxRetries) {
              console.warn("Could not generate perfectly balanced schedule after 100 attempts. Relaxing games-per-player constraint...");
            }
            // retry automatically
          }
        }

        // --- Fallback: relax games-per-player constraint ---
        if (!schedule) {
          console.log("Generating schedule without games-per-player constraint (still no repeated pairings)...");
          schedule = generateScheduleRelaxed();
        }

        return schedule;
      }

      function minutesToTime(total) {
        const h = Math.floor(total / 60);
        const m = total % 60;
        return String(h).padStart(2, "0") + ":" + String(m).padStart(2, "0");
      }

      function renamePlayer(playerId, newName) {
        const trimmed = newName.trim();
        if (!trimmed) return;

        const player = players.find((p) => p.id === playerId);
        if (!player) return;

        player.name = trimmed;

        undoStack.forEach((state) => {
          state.forEach((slot) => {
            slot.matches.forEach((match) => {
              match.players.forEach((p) => {
                if (p.id === playerId) p.name = trimmed;
              });
            });
          });
        });

        render();
        renderPlayerPalette();
        renderAlerts();
      }

      // ---------------------------
      // Render
      // ---------------------------
      function render() {
        const { counts, average } = getPlayerGameStats();
        const root = document.getElementById("schedule");
        root.innerHTML = "";

        // Always create left column
        let leftCol = document.createElement("div");
        leftCol.className = "schedule-column";

        let rightCol = null;

        if (twoColumnRounds) {
          const wrapper = document.createElement("div");
          wrapper.className = "schedule-columns";

          rightCol = document.createElement("div");
          rightCol.className = "schedule-column";

          wrapper.appendChild(leftCol);
          wrapper.appendChild(rightCol);
          root.appendChild(wrapper);
        } else {
          // Single-column mode = left column only
          root.appendChild(leftCol);
        }

        schedule.forEach((slot, i) => {
          const slotDiv = document.createElement("div");
          slotDiv.className = "slot";

          slotDiv.innerHTML = `
        <h3>Round ${i + 1} (${slot.startTime})</h3>
        <div class="matches"></div>
      `;

          const matchesDiv = slotDiv.querySelector(".matches");

          slot.matches.forEach((match) => {
            const matchDiv = document.createElement("div");
            matchDiv.className = "match";

            matchDiv.innerHTML = `
          <strong>${courtNames[match.court - 1]}</strong>
          <div class="players"></div>
        `;

            const playersDiv = matchDiv.querySelector(".players");
            playersDiv.innerHTML = "";

            // Helper to render a single player (keeps ALL logic)
            function renderPlayer(player, index) {
              const playerDiv = document.createElement("div");
              playerDiv.className = "player";
              playerDiv.textContent = player.name;
              playerDiv.draggable = true;

              playerDiv.dataset.matchId = match.id;
              playerDiv.dataset.playerId = player.id;
              playerDiv.dataset.playerIndex = index;

              // ---- Existing validation logic ----
              const duplicateInMatch = match.players.filter((p) => p.id === player.id).length > 1;

              const duplicateInSlot = slot.matches.filter((m) => m.id !== match.id).some((m) => m.players.some((p) => p.id === player.id));

              if (duplicateInMatch || duplicateInSlot) {
                playerDiv.classList.add("invalid");
              }

              // ---- Existing selection logic ----
              const count = counts[player.id];
              if (selectedPlayerIds.has(player.id)) {
                if (count > average) {
                  playerDiv.classList.add("selected-player-above-average");
                } else if (count < average) {
                  playerDiv.classList.add("selected-player-below-average");
                } else {
                  playerDiv.classList.add("selected-player");
                }
              }

              attachDragEvents(playerDiv);
              return playerDiv;
            }

            // ---- Team A ----
            const teamA = document.createElement("div");
            teamA.className = "team";

            teamA.appendChild(renderPlayer(match.players[0], 0));
            teamA.appendChild(renderPlayer(match.players[1], 1));

            playersDiv.appendChild(teamA);

            // ---- VS ----
            const vsDiv = document.createElement("div");
            vsDiv.textContent = "VS";
            vsDiv.className = "vs";
            playersDiv.appendChild(vsDiv);

            // ---- Team B ----
            const teamB = document.createElement("div");
            teamB.className = "team";

            teamB.appendChild(renderPlayer(match.players[2], 2));
            teamB.appendChild(renderPlayer(match.players[3], 3));

            playersDiv.appendChild(teamB);

            matchesDiv.appendChild(matchDiv);
          });

          if (!twoColumnRounds) {
            // All rounds go into left column
            leftCol.appendChild(slotDiv);
          } else {
            const half = Math.ceil(schedule.length / 2);
            if (i < half) {
              leftCol.appendChild(slotDiv);
            } else {
              rightCol.appendChild(slotDiv);
            }
          }
        });
      }

      function getPlayerGameStats() {
        const counts = {};
        let totalGames = 0;

        players.forEach((p) => (counts[p.id] = 0));

        schedule.forEach((slot) => {
          slot.matches.forEach((match) => {
            match.players.forEach((player) => {
              counts[player.id]++;
              totalGames++;
            });
          });
        });

        const average = Math.round(totalGames / players.length);

        return { counts, average };
      }

      // ---------------------------
      // Render Player Palette
      // ---------------------------
      function renderPlayerPalette() {
        const listDiv = document.getElementById("playerList");
        listDiv.innerHTML = "";

        // ---- Sort Toggle ----
        const toggleRow = document.createElement("div");
        toggleRow.style.display = "flex";
        toggleRow.style.alignItems = "center";
        toggleRow.style.gap = "8px";
        toggleRow.style.marginBottom = "10px";

        const label = document.createElement("strong");
        label.textContent = "Sort by:";

        const toggleBtn = document.createElement("button");

        function updateToggleLabel() {
          switch (playerSortMode) {
            case "alpha":
              toggleBtn.textContent = "[A â†’ Z]";
              break;
            case "games-desc":
              toggleBtn.textContent = "[Games â†“]";
              break;
            case "games-asc":
              toggleBtn.textContent = "[Games â†‘]";
              break;
          }
        }

        toggleBtn.onclick = () => {
          // cycle modes
          if (playerSortMode === "alpha") {
            playerSortMode = "games-desc";
          } else if (playerSortMode === "games-desc") {
            playerSortMode = "games-asc";
          } else {
            playerSortMode = "alpha";
          }

          updateToggleLabel();
          renderPlayerPalette();
        };

        updateToggleLabel();

        toggleRow.appendChild(label);
        toggleRow.appendChild(toggleBtn);
        listDiv.appendChild(toggleRow);

        const { counts, average } = getPlayerGameStats();

        const countEl = document.getElementById("playerCount");
        countEl.textContent = players.length;

        const sortedPlayers = [...players].sort((a, b) => {
          const countA = counts[a.id] ?? 0;
          const countB = counts[b.id] ?? 0;

          // Always use name as tie-breaker
          const nameCompare = a.name.localeCompare(b.name);

          if (playerSortMode === "alpha") {
            return nameCompare;
          }

          if (playerSortMode === "games-desc") {
            if (countB !== countA) return countB - countA; // high â†’ low
            return nameCompare; // fallback A â†’ Z
          }

          if (playerSortMode === "games-asc") {
            if (countA !== countB) return countA - countB; // low â†’ high
            return nameCompare; // fallback A â†’ Z
          }

          return 0;
        });

        sortedPlayers.forEach((player) => {
          const playerDiv = document.createElement("div");
          playerDiv.className = "player palette-player";
          playerDiv.draggable = true;
          playerDiv.dataset.playerId = player.id;

          // --- Name span ---
          const nameSpan = document.createElement("span");
          nameSpan.textContent = player.name;
          nameSpan.style.flex = "1";

          playerDiv.addEventListener("mouseenter", () => {
            const allSchedulePlayers = document.querySelectorAll("#schedule .player");
            allSchedulePlayers.forEach((p) => {
              if (p.dataset.playerId !== player.id) {
                p.classList.add("dimmed");
                p.classList.remove("highlighted");
              } else {
                p.classList.add("highlighted");
                p.classList.remove("dimmed");
              }
            });
          });

          playerDiv.addEventListener("mouseleave", () => {
            const allSchedulePlayers = document.querySelectorAll("#schedule .player");
            allSchedulePlayers.forEach((p) => {
              p.classList.remove("dimmed", "highlighted");
            });
          });

          playerDiv.appendChild(nameSpan);

          // --- Game count badge ---
          const countBadge = document.createElement("span");
          countBadge.className = "game-count";
          const count = counts[player.id];
          countBadge.textContent = count;

          if (count > average) countBadge.classList.add("above-average");
          else if (count < average) countBadge.classList.add("below-average");

          countBadge.addEventListener("click", (e) => {
            e.stopPropagation();

            if (selectedPlayerIds.has(player.id)) {
              selectedPlayerIds.delete(player.id);
            } else {
              selectedPlayerIds.add(player.id);
            }

            render();
            renderPlayerPalette();
          });

          playerDiv.appendChild(countBadge);

          // Highlight if selected
          if (selectedPlayerIds.has(player.id)) {
            playerDiv.classList.add("selected-player");
          }

          // --- Double-click on the whole row = rename ---
          if (!isReadOnly) {
            playerDiv.addEventListener("dblclick", (e) => {
              e.stopPropagation();

              const input = document.createElement("input");
              input.type = "text";
              input.value = player.name;
              input.style.width = "100%";

              nameSpan.replaceWith(input);
              input.focus();
              input.select();

              const commit = () => renamePlayer(player.id, input.value);

              input.addEventListener("blur", commit);
              input.addEventListener("keydown", (e) => {
                if (e.key === "Enter") commit();
                if (e.key === "Escape") renderPlayerPalette();
              });

              input.addEventListener("mousedown", (e) => e.stopPropagation());
            });
          }

          attachDragEvents(playerDiv);
          listDiv.appendChild(playerDiv);
        });

        // ---- Court name editor ----
        const editor = document.createElement("div");
        editor.style.marginTop = "12px";
        editor.style.paddingTop = "10px";
        editor.style.borderTop = "1px solid #444";

        const title = document.createElement("strong");
        title.textContent = "Court Names";
        editor.appendChild(title);

        courtNames.forEach((name, index) => {
          const row = document.createElement("div");
          row.style.marginTop = "6px";

          const input = document.createElement("input");
          input.type = "text";
          input.value = name;
          input.style.width = "90%";

          input.addEventListener("input", (e) => {
            courtNames[index] = e.target.value || `Court ${index + 1}`;
            render();
          });

          row.appendChild(input);
          editor.appendChild(row);
        });

        listDiv.appendChild(editor);
      }

      // ---------------------------
      // Drag & Drop Logic
      // ---------------------------
      let dragged = null;

      function attachDragEvents(el) {
        if (isReadOnly) {
          el.draggable = false;
          return;
        }
        el.addEventListener("dragstart", (e) => {
          dragged = el;
          e.dataTransfer.effectAllowed = "move";
          const allSchedulePlayers = document.querySelectorAll("#schedule .player");
          allSchedulePlayers.forEach((p) => {
            p.classList.remove("dimmed", "highlighted");
          });
        });

        el.addEventListener("dragover", (e) => {
          e.preventDefault();
          el.classList.add("drag-over");
        });

        el.addEventListener("dragleave", () => {
          el.classList.remove("drag-over");
        });

        el.addEventListener("drop", (e) => {
          e.preventDefault();
          el.classList.remove("drag-over");

          // Determine if dragged is from palette or match
          const fromMatchId = dragged.dataset.matchId || null;
          const fromPlayerId = dragged.dataset.playerId;
          const fromPlayerIndex = dragged.dataset.playerIndex != null ? Number(dragged.dataset.playerIndex) : null;

          const toMatchId = el.dataset.matchId;
          const toPlayerId = el.dataset.playerId;
          const toPlayerIndex = Number(el.dataset.playerIndex);

          swapPlayers(fromMatchId, fromPlayerId, fromPlayerIndex, toMatchId, toPlayerId, toPlayerIndex);
          render();
          renderPlayerPalette();
          renderAlerts();
        });
      }

      // ---------------------------
      // Swap Players in Data Model
      // ---------------------------
      function swapPlayers(fromMatchId, fromPlayerId, fromPlayerIndex, toMatchId, toPlayerId, toPlayerIndex) {
        if (fromPlayerId == toPlayerId || !toMatchId) {
          return;
        }
        // Push current state to undo stack
        undoStack.push(JSON.parse(JSON.stringify(schedule)));
        if (undoStack.length > MAX_UNDO) {
          undoStack.shift();
        }

        let fromPlayer, toPlayer;
        let fromSlot, toSlot;
        let fromMatch, toMatch;

        // Locate players + matches + slots
        schedule.forEach((slot) => {
          slot.matches.forEach((match) => {
            if (!fromMatchId && !fromPlayer) {
              fromPlayer = players.find((p) => p.id === fromPlayerId);
            } else if (match.id === fromMatchId) {
              fromMatch = match;
              fromSlot = slot;
              fromPlayer = match.players.find((p) => p.id === fromPlayerId);
            }

            if (match.id === toMatchId) {
              toMatch = match;
              toSlot = slot;
              toPlayer = match.players.find((p) => p.id === toPlayerId);
            }
          });
        });

        if (!fromPlayer || !toPlayer) return;
        schedule.forEach((slot) => {
          slot.matches.forEach((match) => {
            match.players = match.players.map((p, index) => {
              if (!fromMatchId) {
                // From player palette
                if (p.id === toPlayerId && match.id === toMatchId && index == toPlayerIndex) {
                  return fromPlayer;
                } else if (globalSwap && !fromMatchId) {
                  if (p.id === toPlayerId) return fromPlayer;
                  if (p.id === fromPlayerId) return toPlayer;
                }
              } else {
                if (globalSwap) {
                  // From schedule; global swap enabled
                  if (p.id === fromPlayerId) return toPlayer;
                  if (p.id === toPlayerId) return fromPlayer;
                } else {
                  // From schedule; global swap disabled
                  if (p.id === fromPlayerId && match.id === fromMatchId && index == fromPlayerIndex) return toPlayer;
                  if (p.id === toPlayerId && match.id === toMatchId && index == toPlayerIndex) return fromPlayer;
                }
              }

              return p;
            });
          });
        });
      }

      function undoSwap() {
        if (undoStack.length === 0) return;
        schedule = undoStack.pop();
        render();
        renderPlayerPalette();
        renderAlerts();
      }

      // ---------------------------
      // Undo swap using keybind
      // ---------------------------
      document.addEventListener("keydown", function (e) {
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "z") {
          e.preventDefault();
          undoSwap();
        }
      });

      function generatePairAlerts(schedule) {
        const togetherMap = new Map();
        const againstMap = new Map();

        function normalizePair(a, b) {
          return [a, b].sort().join("|");
        }

        function bump(map, key, match) {
          if (!map.has(key)) {
            map.set(key, { count: 0, matches: [] });
          }
          const entry = map.get(key);
          entry.count++;
          entry.matches.push(match);
        }

        schedule.forEach((slot) => {
          slot.matches.forEach((match) => {
            const p = match.players;
            if (!p || p.length !== 4) return;

            const teamA = [p[0].name, p[1].name];
            const teamB = [p[2].name, p[3].name];

            // ---- Together ----
            bump(togetherMap, normalizePair(teamA[0], teamA[1]), match);
            bump(togetherMap, normalizePair(teamB[0], teamB[1]), match);

            // ---- Against ----
            teamA.forEach((a) => {
              teamB.forEach((b) => {
                bump(againstMap, normalizePair(a, b), match);
              });
            });
          });
        });

        return { togetherMap, againstMap };
      }

      function buildAlertList(schedule) {
        const { togetherMap, againstMap } = generatePairAlerts(schedule);
        const alerts = [];

        function pushAlerts(map, type, separator) {
          map.forEach((entry, key) => {
            if (entry.count <= 1) return;

            const [a, b] = key.split("|");

            alerts.push({
              key,
              type, // "together" | "against"
              players: [a, b],
              matches: entry.matches,
              text: `${a} ${separator} ${b}: ${entry.count} times`,
              count: entry.count,
            });
          });
        }

        pushAlerts(togetherMap, "together", "+");
        pushAlerts(againstMap, "against", "VS");

        // return alerts.sort((a, b) => a.text.localeCompare(b.text));
        return alerts;
      }

      function highlightAlert(alert) {
        const schedulePlayers = document.querySelectorAll("#schedule .player");

        schedulePlayers.forEach((el) => {
          const playerName = el.textContent.trim();
          const matchId = el.dataset.matchId;

          const isPlayerInAlert = alert.players.includes(playerName);
          const isMatchInAlert = alert.matches.some((m) => m.id == matchId);

          if (isPlayerInAlert && isMatchInAlert) {
            el.classList.add("highlighted");
            el.classList.remove("dimmed");
          } else {
            el.classList.add("dimmed");
            el.classList.remove("highlighted");
          }
        });
      }

      function clearAlertHighlight() {
        const schedulePlayers = document.querySelectorAll("#schedule .player");
        schedulePlayers.forEach((el) => {
          el.classList.remove("highlighted", "dimmed");
        });
      }

      function renderAlerts() {
        const alertDiv = document.getElementById("alerts");
        if (!alertDiv) return;

        alertDiv.innerHTML = "<h3>Alerts</h3>";

        const alerts = buildAlertList(schedule);

        if (alerts.length === 0) {
          const ok = document.createElement("div");
          ok.textContent = "No issues found ðŸŽ‰";
          ok.style.opacity = "0.7";
          alertDiv.appendChild(ok);
          return;
        }

        alerts.forEach((alert) => {
          const row = document.createElement("div");
          row.textContent = alert.text;
          row.className = "alert-row";

          row.addEventListener("mouseenter", () => {
            highlightAlert(alert);
          });

          row.addEventListener("mouseleave", () => {
            clearAlertHighlight();
          });

          alertDiv.appendChild(row);
        });
      }

      function toggleGlobalSwap() {
        globalSwap = !globalSwap;
        const btn = document.getElementById("globalSwapBtn");
        btn.textContent = "[Global player swap: " + (globalSwap ? "Yes" : "No") + "]";
      }

      function navigateToHome() {
        window.location.href = "index";
      }
      function navigateCreate() {
        window.location.href = "event-create.html";
      }

      if (isReadOnly) {
        document.querySelector("header")?.remove();

        palette.style.display = "none";
        alertsPanel.style.display = "none";

        // Also hide their toggle buttons
        togglePaletteBtn && (togglePaletteBtn.style.display = "none");
        toggleAlertsBtn && (toggleAlertsBtn.style.display = "none");
        document.querySelectorAll(".player").forEach((el) => {
          el.style.cursor = "default";
        });
      }
    </script>
  </body>
</html>
